;;;; -*- Lisp -*-
;;;;
;;;; $Id$
;;;;
;;;; Routines to read and write score files for various synthesis systems.
;;;;

(in-package :multires-rhythm)

(defgeneric save-to-file (object-to-write file-stream-or-name)
  (:documentation "Writes the object to the named file or given stream"))

;;; General MIDI percussion map key numbers:
(defparameter *cowbell* 56)
(defparameter *claves* 75)
(defparameter *hi-woodblock* 76)
(defparameter *low-woodblock* 77)
(defparameter *closed-hi-hat* 42)
(defparameter *bass-drum* 36)
(defparameter *snare-drum* 38)

(let ((note-tag 0))

  ;; TODO make this a method that is accompanied by a version that plays samples.
  (defun write-note (file-handle part time duration key-number &key (amplitude 1.0))
    "Writes out to file-handle the given note specified at an onset time
  instant. Increments the note-tag."
    (format file-handle "t ~,3f;~%" time)
    (format file-handle "~a (~f ~d) " part duration note-tag)
    ;;(cond 
    ;; ((eql instrument "SamplePlayer")
    ;;  (format file-handle "filename: \"~a\" " "~/Library/Sounds/hihat_closed.aiff"))
    ;; ((eql instrument "midi")
    ;;  (format file-handle "note: g3k, ")))
    (format file-handle "keyNum: ~d, " key-number)
    (format file-handle "amplitude: ~f;~%" amplitude)
    (incf note-tag))

    ;;(write-note velocities(timeIndex))

  (defun write-labelled-notes (file-handle labelled-notes)
    (loop
       for (part-label note) in labelled-notes
       do (write-note file-handle 
		      part-label
		      (first note) 
		      (second note)
		      (fourth note)
		      :amplitude (third note))))

  ;; normally we handclap using a sample. For now, a score is a list of parts, may one day be an object.
  (defun save-scorefile (filename score &key (description "")
			 (instrument "SamplePlayer") 
			 (midi-channels (make-list (length score) :initial-element 0))
			 (tempo 60))
    "Save the part list as a MusicKit scorefile."
    (with-open-file (f filename :direction :output :if-exists :supersede)
      (format f "// MusicKit scorefile ~a~%" filename)
      (format f "// Generated by save-score~%")
      (format f "info tempo: ~a, title: \"~a\";~%" tempo description)
      (loop
	 for part in score ;; iterate through the parts in the score.
	 for midi-channel in midi-channels
	 for part-index = 0 then (incf part-index)
	 for part-name = (format nil "part~d" part-index)
	 for part-labelled-notes = (mapcar (lambda (note) (list part-name note)) part)
	 with time-ordered = '()
	 do 
	   (format f "part ~a;~%" part-name)
	   (format f "~a synthPatchCount: 1, synthPatch: \"~a\", midiChan: ~d;~%~%"
		   part-name instrument midi-channel)
	   (setf time-ordered (merge 'list time-ordered part-labelled-notes #'< :key #'caadr))
	 finally 
	   (format f "BEGIN;~%")
	   (setf note-tag 0)
	   (write-labelled-notes f time-ordered)
	   (format f "END;~%")))))

;; (key-numbers (list *low-woodblock* *cowbell* *claves*))

;; (save-scorefile "test-score.score" (list (part-from-rhythm (rhythm-of-onsets (0.0 1.0 2.0) 
;; (part-from-rhythm (rhythm-of-onsets (0.0 1.1 1.9 2.5 5.7))
;; (part-from-rhythm (rhythm-of-onsets (0.0 1.0 2.1 3.1))))

