;;; -*- Lisp -*-

;;; A CM/CLM instrument designed to emit a rhythm frequency (200Hz
;;; S.R) impulse at the onset time of each note. This is then
;;; transformed using a modulated Gaussian Wavelet filter bank to
;;; produce a spectral density plot (akin to a sonogram but using
;;; Kronland-Martinet's et. al. wavelet instead of a STFT).
;;;
;;; Leigh Smith 2/10/95

(definstrument rhythm-onset (start duration note amplitude)
  ;; Our output ignores note, but uses start (onset time), duration
  ;; and amplitude. The note parameter retains a compatibility with
  ;; more complex instruments like rhythm-tone.
  (let (beg end) (multiple-value-setq (beg end) (get-beg-end start duration))
       ;; run must have the sample loop first
       (run (loop for i from beg to end do
		  (outa i (if (= i beg) ; clip so that 1.0 is not -1.0
			      (max -1.0 (min .9999 amplitude))
			    0))))))

;;; Like rhythm-onset, but this produces no trailing space, it is literally a
;;; one sample duration instrument.
(definstrument rhythm-dirac (start duration note amplitude)
  ;; Our output ignores note, but uses start (onset time) and amplitude.
  ;; The parameters retain a compatibility with
  ;; more complex instruments like rhythm-tone.
  (let (beg end) (multiple-value-setq (beg end) (get-beg-end start duration))
       ;; run must have the sample loop first
       (run (outa beg (max -1.0 (min .9999 amplitude))))))

;; Much like rhythm-onset, but half-way through the duration (which
;; is important), we place a negative impulse. This is designed to
;; reflect the frequency of the rhythm. Actually, we should alternate
;; the sign of the onset impulse, as what will happen is we imply a
;; frequency twice the rate... The whole point of the exercise is to
;; remove the wierd 2nd harmonic which occurs in the analysis.
(definstrument rhythm-bipolar-onset (start duration note amplitude)
  (- rhythm-impulse-polarity)		; swap polarity on each call
  (let (beg end) (multiple-value-setq (beg end) (get-beg-end start duration))
					; run must have the sample loop first
       (outa beg (* amplitude rhythm-impulse-polarity))
       (run (loop for i from (+ beg 1) to end do
		  (outa i 0)))))

(setf rhythm-impulse-polarity 1)	; initialise our polarity to +ve

;;; A simple instrument designed to produce an envelope of audible sound 
;;; to provide higher frequency components for our wavelet transforms to
;;; indicate.
;;; To keep the stray harmonics to a minimum we use a sinusoid of fundamental
;;; frequency only (boring and practical).
(definstrument rhythm-tone (start duration note amplitude)
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((sinewave (make-oscil :frequency (pitch note)))
	  (sharp-attack (make-env :start beg :end end
				  :envelope '(0 0 0.2 0.9 0.3 0.8 0.7 0.8 1.0 0))))
      (run (loop for i from beg to end do
		 (outa i (* amplitude (env sharp-attack) (oscil sinewave))))))))

;;; A simple instrument designed to produce an envelope of audible sound 
;;; to provide higher frequency components for our wavelet transforms to
;;; indicate.
;;; To keep the stray harmonics to a minimum we use a sinusoid of fundamental
;;; frequency only (boring and practical).
(definstrument rhythm-bowed-tone (start duration note amplitude)
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((sinewave (make-oscil :frequency (pitch note)))
	  (slow-attack (make-env :start beg :end end
				  :envelope '(0 0 0.7 0.9 0.8 0.9 0.9 0.6 1.0 0))))
      (run (loop for i from beg to end do
		 (outa i (* amplitude (env slow-attack) (oscil sinewave))))))))


;;; An even simpler, less auditory, signal energy function. Here we
;;; create a sawtooth, with instantaneous attack, a linear ramp decay
;;; to zero, with no underlying fundamental (pitch) frequency.
(definstrument rhythm-energy-ramp (start duration note amplitude)
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((ramp-env (make-env :start beg :end end
			       :envelope '(0 0 0.001 1 1.0 0))))
       (run (loop for i from beg to end do
		  (outa i (* amplitude (env ramp-env))))))))

;;; A square wave, non auditory, signal energy function. Here we
;;; create a square-wave, with instantaneous attack a ramp decay, with no
;;; underlying fundamental (pitch) frequency
(definstrument rhythm-energy-square (start duration note amplitude)
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (run (loop for i from beg to end do
	       (outa i amplitude)))))

;;; A Gaussian envelope function. This is designed to localise
;;; frequency, at the expense of time.
;;; At issue is whether the std. deviation differs with duration and
;;; if the maximum of the curve should differ with amplitude.

;; J.C. Risset's Bell curve, per Schottstaedt's doco.
(defmacro bell-curve (x)
  ;; x from 0.0 to 1.0 creates bell curve between .64e-4 and nearly 1.0
  ;; if x goes on from there, you get more bell curves -- x can be
  ;; an envelope (a ramp from 0 to 1 if you want just a bell curve)
  `(+ .64e-4 (* .1565 (- (exp (- 1.0 (cos (* two-pi ,x)))) 1.0))))

(definstrument rhythm-gaussian (start duration note amplitude)
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((ramp (make-env :envelope '(0 0 1 1) :start beg :end end)))
      (run (loop for i from beg to end do
		 (outa i (* amplitude (bell-curve (env ramp)))))))))

;;; Basically the same as rhythm-gaussian, but we actually generate a
;;; sinusoid to be modulated by the Gaussian envelope.
(definstrument rhythm-gaussian-tone
  (start duration note amplitude &key (panning 0.5))
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((ramp (make-env :envelope '(0 0 1 1) :start beg :end end))
	  (sinewave (make-oscil :frequency (pitch note)))
	  (loc (make-locsig :degree 0 :distance 1 :revscale 0.0)))
      (run (loop for i from beg to end do
		 ;; only pan if we output to a stereo file
		 (setf (locs-ascl loc) (- 1.0 panning))
		 (setf (locs-bscl loc) panning)
		 (locsig loc i (* amplitude (bell-curve (env ramp))
			    (oscil sinewave))))))))

;;; A sinusoid, non auditory, signal energy function. Here we create
;;; a single frequency signal of wavelength 
;;(defmethod XX-print-parameters (obj )
;;  (formatting-slots ()

;;;
;;; Gaussian amplitude modulation of a fixed sinusoid carrier.
;;; The period of the amplitude modulation is the duration, with DC
;;; shifted sinusoid forming the amplitude envelope.
(definstrument rhythm-periodicity-pitch-gaussian
  (start duration note amplitude &key (panning 0.5))
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((ramp (make-env :envelope '(0 0 1 1) :start beg :end end))
	  (sinewave (make-oscil :frequency (pitch note)))
	  (loc (make-locsig :degree 0 :distance 1 :revscale 0.0)))
      (run (loop for i from beg to end do
		 ;; only pan if we output to a stereo file
		 (setf (locs-ascl loc) (- 1.0 panning))
		 (setf (locs-bscl loc) panning)
		 (locsig loc i (* amplitude (bell-curve (env ramp))
			    (oscil sinewave))))))))
;;;
;;; Sinusoidal amplitude modulation of a fixed sinusoid carrier.
;;; The period of the amplitude modulation is the duration, with DC
;;; shifted and scaled sinusoid forming the amplitude envelope.
(definstrument rhythm-periodicity-pitch
  (start duration note amplitude &key (panning 0.5))
  (multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((sinewave (make-oscil :frequency (pitch note)))
	  (am (make-oscil :frequency (/ 1.0 duration) :initial-phase 4.71238898))
 	  (loc (make-locsig :degree 0 :distance 1 :revscale 0.0)))
      (run (loop for i from beg to end do
		 ;; only pan if we output to a stereo file
		 (setf (locs-ascl loc) (- 1.0 panning))
		 (setf (locs-bscl loc) panning)
		 (locsig loc i (* amplitude (/ (+ (oscil am) 1.0) 2.0)
			 (oscil sinewave))))))))

;;;
;;; Sinusoidal amplitude modulation of a fixed sinusoid carrier.
;;; The period of the amplitude modulation is the duration, with DC
;;; shifted and scaled sinusoid forming the amplitude envelope.
(definstrument rhythm-periodicity-pitch-envelope
(start duration note amplitude)
(multiple-value-bind (beg end) (get-beg-end start duration)
    (let ((am (make-oscil :frequency (/ 1.0 duration) :initial-phase 4.71238898)))
      (run (loop for i from beg to end do
		 (outa i 
		       (max -1.0 (min .9999 (* amplitude (/ (+ (oscil am) 1.0) 2.0))))))))))

;;;
;;; Should do an instrument that does Gaussian enveloped noise bursts.
;;;
